# CH 23. IOCP(Input Output Completion Port)

## 23-1. Overlapped IO를 기반으로 IOCP 이해하기

### 넌-블로킹 모드의 소켓 구성하기

넌-블로킹 모드의 소켓 구성

```c
SOCKET hLisnSock;

// mode에 저장된 값 1은 넌-블로킹 소켓의 옵션 지정에 사용된다.
int mode = 1;
....
hLisnSock = WSASocket(PF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);

// 입출력 모드(FIONBIO)를 변수 mode에 저장된 값으로 바꿔라.
ioctlsocket(hLisnSock, FIONBIO, &mode); // for non-blocking socket
... .
```

넌-블로킹 모드 소켓의 입출력 이외의 추가적인 특징

-   클라이언트의 연결요청이 존재하지 않는 상태에서 accept 함수가 호출되면 INVALID_SOCKET이 곧바로 반환된다. 그리고 이어서 WSAGetLastError 함수를 호출하면 WSAEWOULDBLOCK가 반환된다.
-   accept 함수호출을 통해서 새로 생성되는 소켓 역시 넌-블로킹 속성을 지닌다.

### Overlapped IO만 가지고 에코 서버 구현해보기.

구조체 변수에 담겨 있는 정보만 참조해도 데이터의 송수신이 가능하도록 구조체를 정의한다.

```c
typedef struct
{
  SOCKET hClntSock;
  char buf[BUF_SIZE];
  WSABUF wsaBuf;
} PRE_IO_DATA, *LPPER_IO_DATA;
```

### Overlapped IO 기반인 에코 서버 예제와 예제의 동작 원리

-   클라이언트가 연결되면 WSARecv 함수를 호출하면서 넌-블로킹 모드로 데이터가 수신되게 하고, 수신이 완료되면 ReadRoutine 함수가 호출되게 한다.
-   ReadRoutine 함수가 호출되면 WSASend 함수를 호출하면서 넌-블로킹 모드로 데이터가 수신되게 하고, 수신이 완료되면 WriteRoutine 함수가 호출되게 한다.
-   이렇게 해서 호출된 WriteRoutine 함수는 다시 WSARecv 함수를 호출하면서 넌-브로킹 모드로 데이터의 수신을 기다린다.

`입출력 완료 시 자동으로 호출되는 Completion Routine 내부로 클라이언트 정보(소켓과 버퍼)를 전달하기 위해서 WSAOVERLAPPED 구조체의 멤버 hEvent를 사용하였다.`

> [CmplRouEchoServ_win.c](https://github.com/wheejinv/C-TCPIP-Practice/blob/master/Window/23_IOCP_CmpRouEchoServ/CmplRouEchoServ_win.c)<br>
> [StableEchoClnt_win.c](https://github.com/wheejinv/C-TCPIP-Practice/blob/master/Window/23_IOCP_StableEchoClient/StableEchoClnt_win.c)

### Overlapped IO 모델에서 IOCP 모델로

Overlapped IO 모델의 에코 서버가 지니는 단점

-   넌-블로킹 모드의 accept 함수와 alertable wait 상태로의 진입을 위한 SleepEx 함수가 번갈아 가며 반복호출되는 것은 성능에 영향을 미칠 수 있다.

문제의 해결

-   accept 함수의 호출은 main 쓰레드가(main 함수) 처리하도록 하고, 별도의 쓰레드를 추가로 하나 생성해서 클라이언트와의 입출력을 담당하게 한다.

### IOCP에서 제안하는 서버의 구현 모델

IOCP에서는 IO를 전담하는 쓰레드를 별도로 생성한다. 그리고 이 쓰레드가 모든 클라이언트를 대상으로 IO를 진행하게 한다.<br>
IOCP를 관찰할 때에 다음의 두 가지 관점에서 관찰이 필요하다.

-   입력과 출력은 넌-블로킹 모드로 동작하는가?
-   넌-블로킹 모드로 진행된 입력과 출력의 완료는 어떻게 확인하는가?
