# CH 17. select보다 나은 epoll

## 17-1 epoll의 이해와 활용

### select 기반의 IO 멀티플렉싱이 느린 이유

-   select 함수호출 이후에 항상 등장하는, 모든 파일 디스크립터를 대상으로 하는 반복문
-   select 함수를 호출할 때마다 인자로 매번 전달해야 하는 관찰대상에 대한 정보들

단점의 해결
`운영체제에게 관찰대상에 대한 정보를 딱 한번만 알려주고서, 관찰대상의 범위, 또는 내용에 변경이 있을 때 변경 사항만 알려주도록 하자.`

> select 함수의 단점 극복을 위해서는 운영체제 레벨에서 멀티플렉싱 기능을 지워해야 한다는 뜻. 리눅스의 epoll, 윈도우의 IOCP

### select와 비교한 epoll 방식의 장점

-   상태변화의 확인을 위한, 전체 파일 디스크립터를 대상으로 하는 반복문이 필요 없다.
-   select 함수에 대응하는 epoll_wait 함수호출 시, 관찰대상의 정보를 매번 전달할 필요가 없다.

### epoll의 구현에 필요한 함수와 구조체

아래의 세 함수 호출을 통해서 epoll의 기능이 완성된다.
`epoll_create` : epoll 파일 디스크립터 저장소 생성<br>
`epoll_ctl` : 저장소에 파일 디스크립터 등록 및 삭제<br>
`epoll_wait` : select 함수와 마찬가지로 파일 디스크립터의 변화를 대기한다.<br>

아래의 구조체는 소켓 디스크립터의 등록 및 이벤트 발생의 확인에 사용되는 구조체이다.

```c
struct epoll_event
{
  __uint32_t   events;
  epoll_data_t data;
}

typedef union epoll_data
{
  void      *prt;
  int        fd;
  __uint32_t u32;
  __uint64_t u64;
} epoll_data_t;
```

#### epoll_create

```c
#include <sys/epoll.h>

// 성공 시 epoll 파일 디스크립터, 실패 시 -1 반환
int epoll_create(int size);
```

-   `size` : epoll 인스턴스의 크기정보. (커널 2.6.8 부터 인자값 무시함.)

epoll_create 함수 호출 시 생성되는 파일 디스크립터의 저장소를 가리켜 'epoll 인스턴스'라 한다.
소멸 시에는 다른 파일 디스크립터들과 마찬가지로 close 함수호출을 통한 종료의 과정을
거칠 필요가 있다.

#### epoll_ctl

epoll 인스턴스 생성 후에 관찰대상이 되는 파일 디스크립터를 등록해야 하는데, 이 때 사용하는 함수가 epoll_ctl 이다.

```c
#include <sys/epoll.h>

// 성공 시 -0, 실패 시 -1 반환
int epoll_ctl(int                 epfd,
              int                 op,
              int                 fd,
              struct epoll_event *event);
```

-   `epfd` : 관찰대상을 등록할 epoll 인스턴스의 파일 디스크립터.<br>
-   `op` : 관찰대상의 추가, 삭제 또는 변경여부 지정.<br>
    -   `EPOLL_CTL_ADD` : 파일 디스크립터를 epoll 인스턴스에 등록한다.
    -   `EPOLL_CTL_DEL` : 파일 디스크립터를 epoll 인스턴스에서 삭제한다.
    -   `EPOLL_CTL_MOD` : 등록된 파일 디스크립터의 이벤트 발생상황을 변경한다.
-   `fd` : 등록할 관찰대상의 파일 디스크립터.<br>
-   `event` : 관찰대상의 관찰 이벤트 유형.

exam.
`epoll_ctl(A, EPOLL_CTL_ADD, B, C);`

> epoll 인스턴스 A에, 파일 디스크립터 B를 등록하되, C를 통해 전달된 이벤트의 관찰을
> 목적으로 등록을 진행한다.

`epoll_ctl(A, EPOLL_CTL_DEL, B, NULL);`

> epoll 인스턴스 A에서 파일 디스크립터 B를 삭제한다.

#### 구조체 epoll_event 를 epoll_ctl 함수에 활용하는 방법

```c
struct epoll_event event;
....
event.events  = EPOLLIN; // 수신한 데이터가 존재하는 상황(이벤트) 발생시
event.data.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &event);
....
```

epoll_event의 멤버인 events에 저장가능한 상수와 이벤트의 유형.

> **비트 OR 연산을 통해 둘 이상을 함께 등록할 수 있음.**

-   `EPOLLIN` : 수신할 데이터가 존재하는 상황
-   `EPOLLOUT` : 출력버퍼가 비워져서 당장 데이터를 전송할 수 있는 상황
-   `EPOLLPRI` : OOB 데이터가 수신된 상황
-   `EPOLLRDHUP` : 연결이 종료되거나 Half-close가 진행된 상황, 이는 엣지 트리거 방식에서 유용하게 사용될 수 있음.
-   `EPOLLERR` : 에러가 발생한 상황
-   `EPOLLET` : 이벤트의 감시를 엣지 트리거 방식으로 동작시킨다.
-   `EPOLLONESHOT` : 이벤트가 한번 감지되면, 해당 파일 디스크립터에서는 더 이상 이벤트를 발생시키지 않는다. 따라서 epoll_ctl 함수의 두 번째 인자로 EPOLL_CTL_MOD 을 전달해서 이벤트를 재설정해야 한다.

#### epoll_wait

```c
#include <sys/epoll.h>

// 성공 시 이벤트가 발생한 파일 디스크립터의 수, 실패 시 -1 반환
int epoll_wait(int                 epfd,
               struct epoll_event *events,
               int                 maxevents,
               int                 timeout);
```

-   `epfd` : 이벤트 발생의 관찰영역인 epoll 인스턴스의 파일 디스크립터.
-   `events` : 이벤트가 발생한 파일 디스크립터가 채워질 버퍼의 주소 값.
-   `maxevents` : 두 번째 인자로 전달도니 주소 값의 버퍼에 등록 가능한 최대 이벤트 수.
-   `timeout` : 1/1000초 단위의 대기시간, -1 전달 시, 이벤트가 발생할 때까지 무한 대기.

exam.

```c
int event_cnt;
struct epoll_event *ep_events;
....
ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE);
....
event_cnt = epoll_wait(epfd, ep_evenets, EPOLL_SIZE, -1);
....
```

#### epoll 기반의 에코 서버
12챕터의 select 관련 예제(echo_selectserv.c)를 변경해서 epoll 서버로 구현하는 것이 공부에 도움됨.

> [echo_epollserv.c]()
