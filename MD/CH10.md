# CH 10\. 멀티프로세스 기반의 서버 구현

## 프로세스의 이해와 활용

`멀티프로세스 기반 서버` : 다수의 프로세스를 생성하는 방식으로 서비스 제공<br>
`멀티플렉싱 기반 서버` : 입출력 대상을 묶어서 관리하는 방식으로 서비스 제공<br>
`멀티쓰레딩 기반 서버` : '클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스 제공'

## 멀티프로세스 기반의 서버 구현

Windows에서는 지원하지 않는 방식이다.

### fork 함수호출을 통한 프로세스의 생성.

```c
#include <unistd.h>

// 성공 시 프로세스 ID, 실패 시 -1 반환
pid_t fork(void);
```

- `부모 프로세스` : fork 함수의 반환 값은 자식 프로세스의 ID
- `자식 프로세스` : fork 함수의 반환 값은 0

> fork() 사용 예제<br>

> - [fork.c](./)

### 좀비 프로세스의 생성 이유

fork 함수의 호출로 생성된 자식 프로세스가 종료되는 상황 두 가지를 예를 들면

- 인자를 전달하면서 exit를 호출하는 경우
- main 함수에서 return문을 실행하면서 값을 반환하는 경우.

exit 함수나 main 함수의 return 문에 의해 반환되는 값 모두 운영체제로 전달된다. `운영체제는 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지 않는다.` 바로 이 상황에 놓여있는 프로세스를 가리켜 좀비 프로세스라 한다.

> zombie 생성 예제

> - [zombie.c](./)

### 좀비 프로세스의 소멸1: wait 함수의 사용

```c
#include <sys/wait.h>

// 성공 시 종료된 자식 프로세스의 ID, 실패 -1 반환
pid_t wait(int *statloc);
```

위 함수가 호출되었을 때, 이미 종료된 자식 프로세스가 있다면, 자식 프로세스가 종료되면서 전달한 값(exit, return값)이 매개변수로 전달된 주소의 변수에 저장된다. 프로세스가 종료되면서 전달한 값 이외에도 다른 정보가 함께 포함되어 있으니, 다음 매크로 함수를 통해서 값의 분리 과정을 거쳐야 한다.

- `WIFEXITED` : 자식 프로세스가 정상 종료한 경우 `참(true)`를 반환한다.
- `WEXITSTATUS` : 자식 프로세스의 전달 값을 반환한다.

> wait 함수는 호출된 시점에서 종료된 자식 프로세스가 없다면, 임의의 자식 프로세스가 종료될 때까지 블로킹(Blocking) 상태에 놓인 다는 특징이 있으므로, 함수의 호출에 주의해야 함.

exam

```c
if (WIFEXITED(status)) { // 정상 종료하였는가.
  puts("Normal termination!");
  printf("Child pass num : %d\n", WEXITSTATUS(status));
}
```

> wait를 사용해서 자식 프로세스가 좀비가 되지 않게 하는 예제<<br>

> - [wait.c](./)
